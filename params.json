{"name":"Enumeration","tagline":"A simple Typedef Enum implementation for php","body":"# Enumerations for php [![Build Status](https://api.travis-ci.org/Alaneor/Enumeration.png)](https://travis-ci.org/Alaneor/Enumeration)\r\n\r\nEvery php programmer at some point wants to put some structure to all those constants defined in their code. Usually one would put those constants under a dedicated class, but that's it; no additional features, no real benefit, no nothing.\r\n\r\n## What if you could get more?\r\n\r\nThis small library aims at providing additional features to your \"Enumerations\" - a set of static values that represent something meaningful to your code.\r\n\r\n## The problem with constants\r\n\r\nLet's say our program will work with animals - various different animals, and we would like each type of animal to have a distinct value ( which I completely made up in this example ). Here's what many programmers currently do:\r\n\r\n```php\r\ndefine( 'MYAPP_ANIMAL_HORSE', 0 );\r\ndefine( 'MYAPP_ANIMAL_DOG', 1 );\r\ndefine( 'MYAPP_ANIMAL_CAT', 2 );\r\n// ...\r\n```\r\n\r\nWhile this certaily works, there is a better way of defining those.\r\n\r\n```php\r\nnamespace MyApp;\r\n\r\nclass Animal\r\n{\r\n  const Horse = 0;\r\n  const Dog = 1;\r\n  const Cat = 2;\r\n}\r\n```\r\n\r\nDefining the constants as a class has several benefits:\r\n\r\n1. You can use real namespacing, which can save you a few typing when using the class\r\n2. It feels more natural to use `Animal::Horse` than `MYAPP_ANIMAL_HORSE`\r\n3. Since it's a class it opens up new possibilities and ideas -> that's where this library comes to use :)\r\n\r\n## How this library helps\r\n\r\nThe above example with a class introduces some issues but also opens up new possibilities.\r\n\r\n1. There's nothing preventing the programmer from instantiating the class\r\n2. What if you wanted to do it the opposite way? -> you have a value and you want to know the constant's name that holds such value in the enumeration?\r\n3. What if you wanted to check if a constant is defined in the Enumeration?\r\n\r\nLet's take a look at another example that demonstrates the use of **Enumerations** provided by this library.\r\n\r\n```php\r\nnamespace MyApp;\r\n\r\n// Let's extend our Enumeration class\r\nclass Animal extends Enumeration\\Enumeration\r\n{\r\n  const Horse = 0;\r\n  const Dog = 1;\r\n  const Cat = 2;\r\n}\r\n\r\n// So far looks the same, but watch now...\r\n\r\n$animal = new Animal; // Throws an exception\r\n\r\nAnimal::isDefined( 'Horse' ); // Returns (bool)true\r\nAnimal::isDefined( 'Cow' ); // Returns (bool)false\r\n\r\n// \"Reverse resolution\"\r\n$value = Animal::Dog;\r\necho Animal::getName( $value ); // prints (string)\"Dog\"\r\n```\r\n\r\nAs you can see, suddenly there's much more you can possibly do with a class as simple as enumeration can be. Learn more in the [API Docs](http://alaneor.github.io/Enumeration/docs) which also include code examples and full method description.\r\n\r\n## Installation\r\n\r\n### Via Composer:\r\n\r\n`composer require alaneor\\enumerations:dev-master`\r\n\r\nComposer's autoloading is supported so as long as you `require \"vendor/autoload.php\";` somewhere in your code you can simply start using it.\r\n\r\n## Documentation\r\n\r\n[API documentation](http://alaneor.github.io/Enumeration/docs) is available online - it includes all public methods you can use and also several code samples and use cases.\r\n\r\n### Offline documentation\r\n\r\nSure! Just install the development dependencies and generate the docs.\r\n\r\n```\r\ncomposer require --dev alaneor\\enumerations:dev-master\r\nphp vendor/bin/phpdoc.php\r\n```\r\n\r\nDocumentation is now available at *./docs/index.html*.\r\n\r\n## License\r\n\r\nThis software is licensed under the **BSD (3-Clause) License**. See the [LICENSE](LICENSE) file for more information.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}